<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />
  <title>OCR to Searchable PDF – One‑Click (Helvetica + Sanitizer, First‑Page Option)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body {
      font-family: system-ui, Arial, sans-serif;
      margin: 24px;
    }

    .row {
      margin: 10px 0;
      display: flex;
      gap: 14px;
      align-items: center;
      flex-wrap: wrap;
    }

    button {
      padding: 10px 14px;
      font-size: 14px;
    }

    label {
      user-select: none;
    }

    #status {
      margin-top: 10px;
      color: #444;
      font-size: 0.95rem;
    }

    #progress {
      margin-top: 6px;
      width: 560px;
      max-width: 100%;
      height: 8px;
      background: #eee;
      border-radius: 4px;
      overflow: hidden;
    }

    #bar {
      height: 100%;
      width: 0%;
      background: #2d7ef7;
      transition: width .2s ease;
    }
  </style>
  <!-- Libraries -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.min.js" defer></script>
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js" defer></script>
  <script src="https://cdn.jsdelivr.net/npm/pdf-lib@1.17.1/dist/pdf-lib.min.js" defer></script>
  <script defer>
    window.addEventListener('load', () => {
      if (!window.pdfjsLib || !window.PDFLib || !window.Tesseract) {
        alert('Libraries failed to load. Open via http:// (e.g., python -m http.server).');
        return;
      }
      pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.worker.min.js';

      const fileInput = document.getElementById('pdfFile');
      const runBtn = document.getElementById('runBtn');
      const firstOnlyChk = document.getElementById('firstOnly');
      const statusEl = document.getElementById('status');
      const barEl = document.getElementById('bar');

      // Defaults tuned for speed+accuracy with StandardFonts (no fontkit)
      const OCR_DPI_FIRST = 375;   // slightly higher for the first page headings
      const OCR_DPI_OTHERS = 325;  // others
      const USE_LINES = true;      // line-level overlay (fast, avoids extra spaces)
      const USE_INVISIBLE_MODE = true; // TRM=3 (invisible but indexed)

      function setStatus(msg, pct = null) {
        statusEl.textContent = msg;
        if (pct == null) return;
        barEl.style.width = `${Math.max(0, Math.min(100, pct))}%`;
      }

      function toStr(v) {
        try {
          if (v == null) return '';
          if (typeof v === 'string') return v;
          if (Array.isArray(v)) return v.map(toStr).join(' ');
          if (typeof v === 'object' && 'text' in v && typeof v.text === 'string') return v.text;
          return String(v);
        } catch { return ''; }
      }

      // Sanitize text for WinAnsi (StandardFonts) + viewer search friendliness
      function normalize(text) {
        const s = toStr(text)
          .replace(/[\r\n]+/g, ' ')      // remove newlines (drawText is single line)
          .replace(/\u00A0/g, ' ')        // NBSP -> space
          .replace(/\u00AD/g, '')         // soft hyphen -> remove
          .replace(/\u2022/g, '-')        // bullet -> hyphen
          .replace(/[\u2010\u2011\u2012\u2013\u2014\u2212]/g, '-') // dashes -> hyphen
          .replace(/[“”]/g, '"')          // curly quotes -> straight
          .replace(/[‘’]/g, "'")          // curly apostrophes -> straight
          .replace(/[\u200B-\u200D\uFEFF]/g, '') // zero-width chars -> remove
          .replace(/\ufb01/g, 'fi')       // ligatures
          .replace(/\ufb02/g, 'fl')
          .normalize('NFKC');
        // Collapse runs of whitespace to a single space (prevents odd gaps)
        return s.replace(/\s{2,}/g, ' ');
      }

      function makeOutputName(srcName) {
        try {
          const now = new Date();
          const pad = n => String(n).padStart(2, '0');
          const ts = `${now.getFullYear()}-${pad(now.getMonth() + 1)}-${pad(now.getDate())}_${pad(now.getHours())}${pad(now.getMinutes())}`;
          const dot = srcName.lastIndexOf('.');
          const base = dot > 0 ? srcName.slice(0, dot) : srcName;
          return `${base} (OCR ${ts}).pdf`;
        } catch { return 'output (OCR).pdf'; }
      }

      // Fit a whole line into OCR bbox width using character/word spacing
      function fitSpacingForLine(font, text, sizePt, bboxWidthPt) {
        const textW = font.widthOfTextAtSize ? font.widthOfTextAtSize(text, sizePt) : sizePt * text.length * 0.5;
        const delta = bboxWidthPt - textW;
        if (Math.abs(delta) < 0.5) return { characterSpacing: 0, wordSpacing: 0 };

        const numSpaces = (text.match(/ /g) || []).length;
        const numChars = Math.max(0, [...text].length - 1);

        if (numSpaces > 0) {
          const ws = delta / numSpaces;
          const wordSpacing = Math.max(-3, Math.min(3, ws));
          const used = wordSpacing * numSpaces;
          const rem = delta - used;
          const cs = (numChars > 0) ? Math.max(-1.5, Math.min(1.5, rem / numChars)) : 0;
          return { characterSpacing: cs, wordSpacing };
        } else {
          const cs = (numChars > 0) ? Math.max(-2, Math.min(2, delta / numChars)) : 0;
          return { characterSpacing: cs, wordSpacing: 0 };
        }
      }

      function byReadingOrder(a, b) {
        // Sort by top (y), then left (x). Each line has bbox {x0,y0,x1,y1} in px space
        const ay = a.bbox?.y0 ?? 0, by = b.bbox?.y0 ?? 0;
        if (Math.abs(ay - by) > 6) return ay - by;
        const ax = a.bbox?.x0 ?? 0, bx = b.bbox?.x0 ?? 0;
        return ax - bx;
      }

      runBtn.onclick = async () => {
        try {
          const file = fileInput.files && fileInput.files[0];
          if (!file) return alert('Choose a PDF first.');

          setStatus('Loading PDF…', 0);
          const buf = await file.arrayBuffer();

          const pdfjsDoc = await pdfjsLib.getDocument({ data: buf }).promise;
          const srcPdf = await PDFLib.PDFDocument.load(buf);
          const outPdf = await PDFLib.PDFDocument.create();
          const font = await outPdf.embedFont(PDFLib.StandardFonts.Helvetica);

          const total = pdfjsDoc.numPages;
          const lastPage = firstOnlyChk.checked ? 1 : total;

          for (let i = 1; i <= lastPage; i++) {
            const OCR_DPI = (i === 1 ? OCR_DPI_FIRST : OCR_DPI_OTHERS);
            const SCALE = OCR_DPI / 72;

            setStatus(`Page ${i}/${lastPage}: rendering…`, (100 * (i - 1)) / Math.max(1, lastPage));
            const page = await pdfjsDoc.getPage(i);
            const rotation = (page.rotate || 0) % 360;
            const viewport = page.getViewport({ scale: SCALE, rotation });

            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            canvas.width = Math.round(viewport.width);
            canvas.height = Math.round(viewport.height);
            ctx.imageSmoothingEnabled = false;
            await page.render({ canvasContext: ctx, viewport }).promise;

            // Grayscale pre-pass (cheap)
            try {
              const img = ctx.getImageData(0, 0, canvas.width, canvas.height);
              const d = img.data;
              for (let j = 0; j < d.length; j += 4) {
                const y = 0.299 * d[j] + 0.587 * d[j + 1] + 0.114 * d[j + 2];
                d[j] = d[j + 1] = d[j + 2] = y;
              }
              ctx.putImageData(img, 0, 0);
            } catch { }

            setStatus(`Page ${i}/${lastPage}: OCR…`, (100 * (i - 1)) / Math.max(1, lastPage));
            const ocr = await Tesseract.recognize(canvas, 'eng', {
              logger: m => {
                if (m.status && typeof m.progress === 'number') {
                  setStatus(`Page ${i}/${lastPage}: ${m.status} (${Math.round(m.progress * 100)}%)`, ((i - 1 + m.progress) / Math.max(1, lastPage)) * 100);
                }
              },
              langPath: 'https://tessdata.projectnaptha.com/5',
              // AUTO handles mixed layouts (headings + table listings) better than SINGLE_BLOCK in many cases
              tessedit_pageseg_mode: 3, // PSM.AUTO
              preserve_interword_spaces: '0'
            });

            const { data } = ocr;

            const [copied] = await outPdf.copyPages(srcPdf, [i - 1]);
            outPdf.addPage(copied);
            const newPage = outPdf.getPage(outPdf.getPageCount() - 1);
            const { height: pageH } = newPage.getSize();

            // Global tweak knobs (points ~ 1/72 inch)
            const OFFSET_X = 0;    // shift text right (+) or left (-)
            const OFFSET_Y = 0;    // shift text up (+) or down (-)

            function drawLine(line) {
              if (!line) return;
              let raw = line.text;
              if (!raw && Array.isArray(line.words)) {
                raw = line.words.map(w => w && w.text).filter(Boolean).join(' ');
              }
              const text = normalize(raw);
              if (!text || !text.trim()) return;

              const bb = line.bbox;
              if (!bb) return;
              const { x0, y0, x1, y1 } = bb;
              if ([x0, y0, x1, y1].some(v => typeof v !== 'number')) return;

              // Convert bbox from OCR-DPI space into PDF points
              const scale = OCR_DPI / 72;
              const hPt = (y1 - y0) / scale;
              const sizePt = font.sizeAtHeight ? font.sizeAtHeight(hPt) : hPt;

              // Use top of bbox as baseline (y1), add optional offset
              const baselineY = (pageH - (y1 / scale)) + OFFSET_Y;
              const xPt = (x0 / scale) + OFFSET_X;
              const bboxWidthPt = (x1 - x0) / scale;

              const spacing = fitSpacingForLine(font, text, sizePt, bboxWidthPt);

              if (USE_INVISIBLE_MODE) {
                newPage.pushOperators(
                  PDFLib.pushGraphicsState(),
                  PDFLib.setTextRenderingMode(PDFLib.TextRenderingMode.Invisible)
                );
              }

              try {
                newPage.drawText(text, {
                  x: xPt,
                  y: baselineY,
                  size: sizePt,
                  font,
                  color: PDFLib.rgb(0, 0, 0),
                  characterSpacing: spacing.characterSpacing,
                  wordSpacing: spacing.wordSpacing,
                });
              } catch (e) {
                const safe = text
                  .replace(/[\u0000-\u001F\u007F]/g, ' ')
                  .replace(/[\r\n]+/g, ' ');
                try {
                  newPage.drawText(safe, {
                    x: xPt,
                    y: baselineY,
                    size: sizePt,
                    font,
                    color: PDFLib.rgb(0, 0, 0),
                  });
                } catch (e2) {
                  console.warn('Skipping a problematic line:', e2);
                }
              }

              if (USE_INVISIBLE_MODE) newPage.pushOperators(PDFLib.popGraphicsState());
            }


            const lines = Array.isArray(data.lines) ? [...data.lines].sort(byReadingOrder) : [];
            const words = Array.isArray(data.words) ? [...data.words].sort(byReadingOrder) : [];

            if (!USE_LINES && words.length) {
              for (const w of words) drawLine({ text: w.text, bbox: w.bbox });
            } else if (lines.length) {
              for (const ln of lines) drawLine(ln);
            }

            canvas.width = canvas.height = 0;
          }

          setStatus('Saving…', 100);
          const pdfBytes = await outPdf.save();
          const blob = new Blob([pdfBytes], { type: 'application/pdf' });
          const a = document.createElement('a');
          a.href = URL.createObjectURL(blob);
          a.download = makeOutputName(file.name);
          document.body.appendChild(a);
          a.click();
          a.remove();
          setStatus('Done. Your download should begin automatically.');
        } catch (err) {
          console.error(err);
          setStatus('Error: ' + (err && err.message ? err.message : String(err)));
          alert('There was an error. Open DevTools (F12) > Console for details.');
        }
      };
    });
  </script>
</head>

<body>
  <h1>OCR to Searchable PDF – One‑Click (Helvetica + Sanitizer, First‑Page Option)</h1>
  <div class="row">
    <input type="file" id="pdfFile" accept="application/pdf" />
    <label><input type="checkbox" id="firstOnly" checked> First page only</label>
    <button id="runBtn">Run OCR</button>
  </div>
  <div id="status"></div>
  <div id="progress">
    <div id="bar"></div>
  </div>
</body>

</html>
